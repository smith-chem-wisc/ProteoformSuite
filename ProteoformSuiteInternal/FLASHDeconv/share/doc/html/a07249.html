<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenMS: MRMRTNormalizer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link rel="shortcut icon" href="favicon.ico" type="image/x-icon" />
<link rel="icon" href="favicon.ico" type="image/x-icon" />
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style_ini.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="OpenMS_75x55_transparent.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenMS
   &#160;<span id="projectnumber">2.4.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="a05822.html">OpenMS</a></li><li class="navelem"><a class="el" href="a07249.html">MRMRTNormalizer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="a07246.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MRMRTNormalizer Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="a07249.html" title="The MRMRTNormalizer will find retention time peptides in data.">MRMRTNormalizer</a> will find retention time peptides in data.  
 <a href="a07249.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="a03011_source.html">OpenMS/ANALYSIS/OPENSWATH/MRMRTNormalizer.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a93fcf23c3bd7e325accced2345e5c6aa"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; std::pair&lt; <a class="el" href="a00001.html#a12109">double</a>, <a class="el" href="a00001.html#a12109">double</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a07249.html#a93fcf23c3bd7e325accced2345e5c6aa">removeOutliersRANSAC</a> (const std::vector&lt; std::pair&lt; <a class="el" href="a00001.html#a12109">double</a>, <a class="el" href="a00001.html#a12109">double</a> &gt; &gt; &amp;pairs, <a class="el" href="a00001.html#a12109">double</a> rsq_limit, <a class="el" href="a00001.html#a12109">double</a> coverage_limit, size_t max_iterations, <a class="el" href="a00001.html#a12109">double</a> max_rt_threshold, size_t sampling_size)</td></tr>
<tr class="memdesc:a93fcf23c3bd7e325accced2345e5c6aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function removes potential outliers in a linear regression dataset.  <a href="a07249.html#a93fcf23c3bd7e325accced2345e5c6aa">More...</a><br /></td></tr>
<tr class="separator:a93fcf23c3bd7e325accced2345e5c6aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f81e1967be462d7764891b9b979fd63"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; std::pair&lt; <a class="el" href="a00001.html#a12109">double</a>, <a class="el" href="a00001.html#a12109">double</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a07249.html#a1f81e1967be462d7764891b9b979fd63">removeOutliersIterative</a> (const std::vector&lt; std::pair&lt; <a class="el" href="a00001.html#a12109">double</a>, <a class="el" href="a00001.html#a12109">double</a> &gt; &gt; &amp;pairs, <a class="el" href="a00001.html#a12109">double</a> rsq_limit, <a class="el" href="a00001.html#a12109">double</a> coverage_limit, bool use_chauvenet, const std::string &amp;method)</td></tr>
<tr class="memdesc:a1f81e1967be462d7764891b9b979fd63"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function removes potential outliers in a linear regression dataset.  <a href="a07249.html#a1f81e1967be462d7764891b9b979fd63">More...</a><br /></td></tr>
<tr class="separator:a1f81e1967be462d7764891b9b979fd63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8027df4a37e94942718af40568e65ea"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="a00001.html#a12109">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a07249.html#af8027df4a37e94942718af40568e65ea">chauvenet_probability</a> (const std::vector&lt; <a class="el" href="a00001.html#a12109">double</a> &gt; &amp;residuals, <a class="el" href="a00001.html#a12329">int</a> pos)</td></tr>
<tr class="memdesc:af8027df4a37e94942718af40568e65ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function computes Chauvenet's criterion probability for a vector and a value whose position is submitted.  <a href="a07249.html#af8027df4a37e94942718af40568e65ea">More...</a><br /></td></tr>
<tr class="separator:af8027df4a37e94942718af40568e65ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cc07ce81c9018c772369e39d4c6010a"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a07249.html#a4cc07ce81c9018c772369e39d4c6010a">chauvenet</a> (const std::vector&lt; <a class="el" href="a00001.html#a12109">double</a> &gt; &amp;residuals, <a class="el" href="a00001.html#a12329">int</a> pos)</td></tr>
<tr class="memdesc:a4cc07ce81c9018c772369e39d4c6010a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function computes Chauvenet's criterion for a vector and a value whose position is submitted.  <a href="a07249.html#a4cc07ce81c9018c772369e39d4c6010a">More...</a><br /></td></tr>
<tr class="separator:a4cc07ce81c9018c772369e39d4c6010a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb5ad1e06e590333f8ce69bf48c50d6a"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a07249.html#adb5ad1e06e590333f8ce69bf48c50d6a">computeBinnedCoverage</a> (const std::pair&lt; <a class="el" href="a00001.html#a12109">double</a>, <a class="el" href="a00001.html#a12109">double</a> &gt; &amp;rtRange, const std::vector&lt; std::pair&lt; <a class="el" href="a00001.html#a12109">double</a>, <a class="el" href="a00001.html#a12109">double</a> &gt; &gt; &amp;pairs, <a class="el" href="a00001.html#a12329">int</a> nrBins, <a class="el" href="a00001.html#a12329">int</a> minPeptidesPerBin, <a class="el" href="a00001.html#a12329">int</a> minBinsFilled)</td></tr>
<tr class="memdesc:adb5ad1e06e590333f8ce69bf48c50d6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes coverage of the RT normalization peptides over the whole RT range, ensuring that each bin has enough peptides.  <a href="a07249.html#adb5ad1e06e590333f8ce69bf48c50d6a">More...</a><br /></td></tr>
<tr class="separator:adb5ad1e06e590333f8ce69bf48c50d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a91d7af35651dbb297e384597b8ee33ac"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="a00001.html#a12329">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a07249.html#a91d7af35651dbb297e384597b8ee33ac">jackknifeOutlierCandidate_</a> (const std::vector&lt; <a class="el" href="a00001.html#a12109">double</a> &gt; &amp;x, const std::vector&lt; <a class="el" href="a00001.html#a12109">double</a> &gt; &amp;y)</td></tr>
<tr class="memdesc:a91d7af35651dbb297e384597b8ee33ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function computes a candidate outlier peptide by iteratively leaving one peptide out to find the one which results in the maximum R^2 of a first order linear regression of the remaining ones. The data points are submitted as two vectors of doubles (x- and y-coordinates).  <a href="a07249.html#a91d7af35651dbb297e384597b8ee33ac">More...</a><br /></td></tr>
<tr class="separator:a91d7af35651dbb297e384597b8ee33ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d1ba3eb4a25a77e7c40e4ebca90147"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="a00001.html#a12329">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a07249.html#a77d1ba3eb4a25a77e7c40e4ebca90147">residualOutlierCandidate_</a> (const std::vector&lt; <a class="el" href="a00001.html#a12109">double</a> &gt; &amp;x, const std::vector&lt; <a class="el" href="a00001.html#a12109">double</a> &gt; &amp;y)</td></tr>
<tr class="memdesc:a77d1ba3eb4a25a77e7c40e4ebca90147"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function computes a candidate outlier peptide by computing the residuals of all points to the linear fit and selecting the one with the largest deviation. The data points are submitted as two vectors of doubles (x- and y-coordinates).  <a href="a07249.html#a77d1ba3eb4a25a77e7c40e4ebca90147">More...</a><br /></td></tr>
<tr class="separator:a77d1ba3eb4a25a77e7c40e4ebca90147"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="a07249.html" title="The MRMRTNormalizer will find retention time peptides in data.">MRMRTNormalizer</a> will find retention time peptides in data. </p>
<p>This tool will take a description of RT peptides and their normalized retention time to write out a transformation file on how to transform the RT space into the normalized space.</p>
<p>The principle is adapted from the following publication: Escher, C. et al. (2012), Using iRT, a normalized retention time for more targeted measurement of peptides. Proteomics, 12: 1111-1121. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a4cc07ce81c9018c772369e39d4c6010a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cc07ce81c9018c772369e39d4c6010a">&#9670;&nbsp;</a></span>chauvenet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool chauvenet </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="a00001.html#a12109">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>residuals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00001.html#a12329">int</a>&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function computes Chauvenet's criterion for a vector and a value whose position is submitted. </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE, if Chauvenet's criterion is fulfilled and the outlier can be removed. </dd></dl>

</div>
</div>
<a id="af8027df4a37e94942718af40568e65ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8027df4a37e94942718af40568e65ea">&#9670;&nbsp;</a></span>chauvenet_probability()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="a00001.html#a12109">double</a> chauvenet_probability </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="a00001.html#a12109">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>residuals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00001.html#a12329">int</a>&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function computes Chauvenet's criterion probability for a vector and a value whose position is submitted. </p>
<dl class="section return"><dt>Returns</dt><dd>Chauvenet's criterion probability </dd></dl>

</div>
</div>
<a id="adb5ad1e06e590333f8ce69bf48c50d6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb5ad1e06e590333f8ce69bf48c50d6a">&#9670;&nbsp;</a></span>computeBinnedCoverage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool computeBinnedCoverage </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; <a class="el" href="a00001.html#a12109">double</a>, <a class="el" href="a00001.html#a12109">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rtRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; <a class="el" href="a00001.html#a12109">double</a>, <a class="el" href="a00001.html#a12109">double</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>pairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00001.html#a12329">int</a>&#160;</td>
          <td class="paramname"><em>nrBins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00001.html#a12329">int</a>&#160;</td>
          <td class="paramname"><em>minPeptidesPerBin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00001.html#a12329">int</a>&#160;</td>
          <td class="paramname"><em>minBinsFilled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes coverage of the RT normalization peptides over the whole RT range, ensuring that each bin has enough peptides. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rtRange</td><td>The (estimated) full RT range in iRT space (theoretical RT) </td></tr>
    <tr><td class="paramname">pairs</td><td>The RT normalization peptide pairs (pair = experimental RT / theoretical RT) </td></tr>
    <tr><td class="paramname">nrBins</td><td>The number of bins to be used </td></tr>
    <tr><td class="paramname">minPeptidesPerBin</td><td>The minimal number of peptides per bin to be used to be considered full </td></tr>
    <tr><td class="paramname">minBinsFilled</td><td>The minimal number of bins needed to be full</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether more than the minimal number of bins are covered </dd></dl>

</div>
</div>
<a id="a91d7af35651dbb297e384597b8ee33ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91d7af35651dbb297e384597b8ee33ac">&#9670;&nbsp;</a></span>jackknifeOutlierCandidate_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="a00001.html#a12329">int</a> jackknifeOutlierCandidate_ </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="a00001.html#a12109">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="a00001.html#a12109">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function computes a candidate outlier peptide by iteratively leaving one peptide out to find the one which results in the maximum R^2 of a first order linear regression of the remaining ones. The data points are submitted as two vectors of doubles (x- and y-coordinates). </p>
<dl class="section return"><dt>Returns</dt><dd>The position of the candidate outlier peptide as supplied by the vector is returned.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a08409.html" title="Exception used if an error occurred while fitting a model to a given dataset.">Exception::UnableToFit</a></td><td>is thrown if fitting cannot be performed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f81e1967be462d7764891b9b979fd63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f81e1967be462d7764891b9b979fd63">&#9670;&nbsp;</a></span>removeOutliersIterative()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt;std::pair&lt;<a class="el" href="a00001.html#a12109">double</a>, <a class="el" href="a00001.html#a12109">double</a>&gt; &gt; removeOutliersIterative </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; <a class="el" href="a00001.html#a12109">double</a>, <a class="el" href="a00001.html#a12109">double</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>pairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00001.html#a12109">double</a>&#160;</td>
          <td class="paramname"><em>rsq_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00001.html#a12109">double</a>&#160;</td>
          <td class="paramname"><em>coverage_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_chauvenet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function removes potential outliers in a linear regression dataset. </p>
<p>Two thresholds need to be defined, first a lower R^2 limit to accept the regression for the RT normalization and second, the lower limit of peptide coverage. The algorithms then selects candidate outlier peptides and applies the Chauvenet's criterion on the assumption that the residuals are normal distributed to determine whether the peptides can be removed. This is done iteratively until both limits are reached.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pairs</td><td>Input data (paired data of type &lt;experimental_rt, theoretical_rt&gt;) </td></tr>
    <tr><td class="paramname">rsq_limit</td><td>Minimal R^2 required </td></tr>
    <tr><td class="paramname">coverage_limit</td><td>Minimal coverage required (the number of points falls below this fraction, the algorithm aborts) </td></tr>
    <tr><td class="paramname">use_chauvenet</td><td>Whether to only remove outliers that fulfill Chauvenet's criterion for outliers (otherwise it will remove any outlier candidate regardless of the criterion) </td></tr>
    <tr><td class="paramname">method</td><td>Outlier detection method ("iter_jackknife" or "iter_residual")</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of pairs is returned if the R^2 limit was reached without reaching the coverage limit. If the limits are reached, an exception is thrown.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a08409.html" title="Exception used if an error occurred while fitting a model to a given dataset.">Exception::UnableToFit</a></td><td>is thrown if fitting cannot be performed (rsq_limit and coverage_limit cannot be fulfilled) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a93fcf23c3bd7e325accced2345e5c6aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93fcf23c3bd7e325accced2345e5c6aa">&#9670;&nbsp;</a></span>removeOutliersRANSAC()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt;std::pair&lt;<a class="el" href="a00001.html#a12109">double</a>, <a class="el" href="a00001.html#a12109">double</a>&gt; &gt; removeOutliersRANSAC </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; <a class="el" href="a00001.html#a12109">double</a>, <a class="el" href="a00001.html#a12109">double</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>pairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00001.html#a12109">double</a>&#160;</td>
          <td class="paramname"><em>rsq_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00001.html#a12109">double</a>&#160;</td>
          <td class="paramname"><em>coverage_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_iterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00001.html#a12109">double</a>&#160;</td>
          <td class="paramname"><em>max_rt_threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sampling_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function removes potential outliers in a linear regression dataset. </p>
<p>Two thresholds need to be defined, first a lower R^2 limit to accept the regression for the RT normalization and second, the lower limit of peptide coverage. The algorithms then selects candidate outlier peptides using the RANSAC outlier detection algorithm and returns the corrected set of peptides if the two thresholds are satisfied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pairs</td><td>Input data (paired data of type &lt;experimental_rt, theoretical_rt&gt;) </td></tr>
    <tr><td class="paramname">rsq_limit</td><td>Minimal R^2 required </td></tr>
    <tr><td class="paramname">coverage_limit</td><td>Minimal coverage required (if the number of points falls below this fraction, the algorithm aborts) </td></tr>
    <tr><td class="paramname">max_iterations</td><td>Maximum iterations for the RANSAC algorithm </td></tr>
    <tr><td class="paramname">max_rt_threshold</td><td>Maximum deviation from fit for the retention time. This must be in the unit of the second dimension (e.g. theoretical_rt). </td></tr>
    <tr><td class="paramname">sampling_size</td><td>The number of data points to sample for the RANSAC algorithm.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of pairs is returned if the R^2 limit was reached without reaching the coverage limit. If the limits are reached, an exception is thrown.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a08409.html" title="Exception used if an error occurred while fitting a model to a given dataset.">Exception::UnableToFit</a></td><td>is thrown if fitting cannot be performed (rsq_limit and coverage_limit cannot be fulfilled) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a77d1ba3eb4a25a77e7c40e4ebca90147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77d1ba3eb4a25a77e7c40e4ebca90147">&#9670;&nbsp;</a></span>residualOutlierCandidate_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="a00001.html#a12329">int</a> residualOutlierCandidate_ </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="a00001.html#a12109">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="a00001.html#a12109">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function computes a candidate outlier peptide by computing the residuals of all points to the linear fit and selecting the one with the largest deviation. The data points are submitted as two vectors of doubles (x- and y-coordinates). </p>
<dl class="section return"><dt>Returns</dt><dd>The position of the candidate outlier peptide as supplied by the vector is returned.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a08409.html" title="Exception used if an error occurred while fitting a model to a given dataset.">Exception::UnableToFit</a></td><td>is thrown if fitting cannot be performed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Dec 9 2019 15:06:48 for OpenMS by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
