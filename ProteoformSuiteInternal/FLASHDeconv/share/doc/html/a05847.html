<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenMS: ms::numpress::MSNumpress Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link rel="shortcut icon" href="favicon.ico" type="image/x-icon" />
<link rel="icon" href="favicon.ico" type="image/x-icon" />
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style_ini.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="OpenMS_75x55_transparent.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenMS
   &#160;<span id="projectnumber">2.4.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="a05845.html">ms</a></li><li class="navelem"><a class="el" href="a05846.html">numpress</a></li><li class="navelem"><a class="el" href="a05847.html">MSNumpress</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ms::numpress::MSNumpress Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a3332d228ff74b97e692fbaf4d289abe7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00001.html#a12109">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05847.html#a3332d228ff74b97e692fbaf4d289abe7">optimalLinearFixedPoint</a> (const <a class="el" href="a00001.html#a12109">double</a> *data, size_t dataSize)</td></tr>
<tr class="separator:a3332d228ff74b97e692fbaf4d289abe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c04bcd8e87d16b05d37f2da406032e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00001.html#a12109">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05847.html#ad8c04bcd8e87d16b05d37f2da406032e">optimalLinearFixedPointMass</a> (const <a class="el" href="a00001.html#a12109">double</a> *data, size_t dataSize, <a class="el" href="a00001.html#a12109">double</a> mass_acc)</td></tr>
<tr class="separator:ad8c04bcd8e87d16b05d37f2da406032e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6757248517c4cd8e2ea365565be082a1"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05847.html#a6757248517c4cd8e2ea365565be082a1">encodeLinear</a> (const <a class="el" href="a00001.html#a12109">double</a> *data, const size_t dataSize, unsigned char *result, <a class="el" href="a00001.html#a12109">double</a> fixedPoint)</td></tr>
<tr class="separator:a6757248517c4cd8e2ea365565be082a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91bd4418b454db0c36725d65319fd527"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05847.html#a91bd4418b454db0c36725d65319fd527">encodeLinear</a> (const std::vector&lt; <a class="el" href="a00001.html#a12109">double</a> &gt; &amp;data, std::vector&lt; unsigned char &gt; &amp;result, <a class="el" href="a00001.html#a12109">double</a> fixedPoint)</td></tr>
<tr class="separator:a91bd4418b454db0c36725d65319fd527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f2fd53ed7d7d27ff8bc57e9cb82784"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05847.html#a34f2fd53ed7d7d27ff8bc57e9cb82784">decodeLinear</a> (const unsigned char *data, const size_t dataSize, <a class="el" href="a00001.html#a12109">double</a> *result)</td></tr>
<tr class="separator:a34f2fd53ed7d7d27ff8bc57e9cb82784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bcbf4fcda5d29eda2a2586467f7fd50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05847.html#a6bcbf4fcda5d29eda2a2586467f7fd50">decodeLinear</a> (const std::vector&lt; unsigned char &gt; &amp;data, std::vector&lt; <a class="el" href="a00001.html#a12109">double</a> &gt; &amp;result)</td></tr>
<tr class="separator:a6bcbf4fcda5d29eda2a2586467f7fd50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a706009e575d08e367761aa1dd6187bf7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05847.html#a706009e575d08e367761aa1dd6187bf7">encodeSafe</a> (const <a class="el" href="a00001.html#a12109">double</a> *data, const size_t dataSize, unsigned char *result)</td></tr>
<tr class="separator:a706009e575d08e367761aa1dd6187bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7536adefaea7531605c56bbf245ac654"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05847.html#a7536adefaea7531605c56bbf245ac654">decodeSafe</a> (const unsigned char *data, const size_t dataSize, <a class="el" href="a00001.html#a12109">double</a> *result)</td></tr>
<tr class="separator:a7536adefaea7531605c56bbf245ac654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b1036fcdd7c864160508d7a20ccffe7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05847.html#a1b1036fcdd7c864160508d7a20ccffe7">encodePic</a> (const <a class="el" href="a00001.html#a12109">double</a> *data, const size_t dataSize, unsigned char *result)</td></tr>
<tr class="separator:a1b1036fcdd7c864160508d7a20ccffe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e37701ccb73f469c2c9c9be7ec78a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05847.html#a92e37701ccb73f469c2c9c9be7ec78a2">encodePic</a> (const std::vector&lt; <a class="el" href="a00001.html#a12109">double</a> &gt; &amp;data, std::vector&lt; unsigned char &gt; &amp;result)</td></tr>
<tr class="separator:a92e37701ccb73f469c2c9c9be7ec78a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa563b352392be10e9a2f74a090f36c63"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05847.html#aa563b352392be10e9a2f74a090f36c63">decodePic</a> (const unsigned char *data, const size_t dataSize, <a class="el" href="a00001.html#a12109">double</a> *result)</td></tr>
<tr class="separator:aa563b352392be10e9a2f74a090f36c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15ced1e3b31ad63489ac259db1d44791"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05847.html#a15ced1e3b31ad63489ac259db1d44791">decodePic</a> (const std::vector&lt; unsigned char &gt; &amp;data, std::vector&lt; <a class="el" href="a00001.html#a12109">double</a> &gt; &amp;result)</td></tr>
<tr class="separator:a15ced1e3b31ad63489ac259db1d44791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ad99f94b29e8e655a184535d30a3ce7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00001.html#a12109">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05847.html#a3ad99f94b29e8e655a184535d30a3ce7">optimalSlofFixedPoint</a> (const <a class="el" href="a00001.html#a12109">double</a> *data, size_t dataSize)</td></tr>
<tr class="separator:a3ad99f94b29e8e655a184535d30a3ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b44c072a385e01d2653edce7409c2fc"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05847.html#a1b44c072a385e01d2653edce7409c2fc">encodeSlof</a> (const <a class="el" href="a00001.html#a12109">double</a> *data, const size_t dataSize, unsigned char *result, <a class="el" href="a00001.html#a12109">double</a> fixedPoint)</td></tr>
<tr class="separator:a1b44c072a385e01d2653edce7409c2fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69394874b8d12cf319c14442ed710f5e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05847.html#a69394874b8d12cf319c14442ed710f5e">encodeSlof</a> (const std::vector&lt; <a class="el" href="a00001.html#a12109">double</a> &gt; &amp;data, std::vector&lt; unsigned char &gt; &amp;result, <a class="el" href="a00001.html#a12109">double</a> fixedPoint)</td></tr>
<tr class="separator:a69394874b8d12cf319c14442ed710f5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e9d03c18c727406f95c2284da348fb2"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05847.html#a5e9d03c18c727406f95c2284da348fb2">decodeSlof</a> (const unsigned char *data, const size_t dataSize, <a class="el" href="a00001.html#a12109">double</a> *result)</td></tr>
<tr class="separator:a5e9d03c18c727406f95c2284da348fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a153c6a393c05828b447e0ff78ad4493c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05847.html#a153c6a393c05828b447e0ff78ad4493c">decodeSlof</a> (const std::vector&lt; unsigned char &gt; &amp;data, std::vector&lt; <a class="el" href="a00001.html#a12109">double</a> &gt; &amp;result)</td></tr>
<tr class="separator:a153c6a393c05828b447e0ff78ad4493c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a6bcbf4fcda5d29eda2a2586467f7fd50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bcbf4fcda5d29eda2a2586467f7fd50">&#9670;&nbsp;</a></span>decodeLinear() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ms::numpress::MSNumpress::decodeLinear </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="a00001.html#a12109">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls lower level decodeLinear while handling vector sizes appropriately</p>
<p>Note that this method may throw a const char* if it deems the input data to be corrupt, i.e.. that the last encoded int does not use the last byte in the data. In addition the last encoded int need to use either the last halfbyte, or the second last followed by a 0x0 halfbyte.</p>
<p>@data vector of bytes to be decoded </p><dl class="section return"><dt>Returns</dt><dd>vector of resulting double (will be resized to the number of doubles) </dd></dl>

</div>
</div>
<a id="a34f2fd53ed7d7d27ff8bc57e9cb82784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34f2fd53ed7d7d27ff8bc57e9cb82784">&#9670;&nbsp;</a></span>decodeLinear() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ms::numpress::MSNumpress::decodeLinear </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>dataSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00001.html#a12109">double</a> *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decodes data encoded by encodeLinear.</p>
<p>result vector guaranteed to be shorter or equal to (|data| - 8) * 2</p>
<p>Note that this method may throw a const char* if it deems the input data to be corrupt, i.e. that the last encoded int does not use the last byte in the data. In addition the last encoded int need to use either the last halfbyte, or the second last followed by a 0x0 halfbyte.</p>
<p>@data pointer to array of bytes to be decoded (need memorycont. repr.) @dataSize number of bytes from *data to decode </p><dl class="section return"><dt>Returns</dt><dd>pointer to were resulting doubles should be stored </dd>
<dd>
the number of decoded doubles, or -1 if dataSize &lt; 4 or 4 &lt; dataSize &lt; 8 </dd></dl>

</div>
</div>
<a id="a15ced1e3b31ad63489ac259db1d44791"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15ced1e3b31ad63489ac259db1d44791">&#9670;&nbsp;</a></span>decodePic() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ms::numpress::MSNumpress::decodePic </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="a00001.html#a12109">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls lower level decodePic while handling vector sizes appropriately</p>
<p>Note that this method may throw a const char* if it deems the input data to be corrupt, i.e. that the last encoded int does not use the last byte in the data. In addition the last encoded int need to use either the last halfbyte, or the second last followed by a 0x0 halfbyte.</p>
<p>@data vector of bytes to be decoded </p><dl class="section return"><dt>Returns</dt><dd>vector of resulting double (will be resized to the number of doubles) </dd></dl>

</div>
</div>
<a id="aa563b352392be10e9a2f74a090f36c63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa563b352392be10e9a2f74a090f36c63">&#9670;&nbsp;</a></span>decodePic() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ms::numpress::MSNumpress::decodePic </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>dataSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00001.html#a12109">double</a> *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decodes data encoded by encodePic</p>
<p>result vector guaranteed to be shorter of equal to |data| * 2</p>
<p>Note that this method may throw a const char* if it deems the input data to be corrupt, i.e. that the last encoded int does not use the last byte in the data. In addition the last encoded int need to use either the last halfbyte, or the second last followed by a 0x0 halfbyte.</p>
<p>@data pointer to array of bytes to be decoded (need memorycont. repr.) @dataSize number of bytes from *data to decode </p><dl class="section return"><dt>Returns</dt><dd>pointer to were resulting doubles should be stored </dd>
<dd>
the number of decoded doubles </dd></dl>

</div>
</div>
<a id="a7536adefaea7531605c56bbf245ac654"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7536adefaea7531605c56bbf245ac654">&#9670;&nbsp;</a></span>decodeSafe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ms::numpress::MSNumpress::decodeSafe </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>dataSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00001.html#a12109">double</a> *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decodes data encoded by encodeSafe.</p>
<p>result vector is the same size as the input data.</p>
<p>Might throw const char* is something goes wrong during decoding.</p>
<p>@data pointer to array of bytes to be decoded (need memorycont. repr.) @dataSize number of bytes from *data to decode </p><dl class="section return"><dt>Returns</dt><dd>pointer to were resulting doubles should be stored </dd>
<dd>
the number of decoded bytes </dd></dl>

</div>
</div>
<a id="a153c6a393c05828b447e0ff78ad4493c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a153c6a393c05828b447e0ff78ad4493c">&#9670;&nbsp;</a></span>decodeSlof() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ms::numpress::MSNumpress::decodeSlof </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="a00001.html#a12109">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls lower level decodeSlof while handling vector sizes appropriately</p>
<p>Note that this method may throw a const char* if it deems the input data to be corrupt.</p>
<p>@data vector of bytes to be decoded </p><dl class="section return"><dt>Returns</dt><dd>vector of resulting double (will be resized to the number of doubles) </dd></dl>

</div>
</div>
<a id="a5e9d03c18c727406f95c2284da348fb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e9d03c18c727406f95c2284da348fb2">&#9670;&nbsp;</a></span>decodeSlof() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ms::numpress::MSNumpress::decodeSlof </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>dataSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00001.html#a12109">double</a> *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decodes data encoded by encodeSlof</p>
<p>The return will include exactly (|data| - 8) / 2 doubles.</p>
<p>Note that this method may throw a const char* if it deems the input data to be corrupt.</p>
<p>@data pointer to array of bytes to be decoded (need memorycont. repr.) @dataSize number of bytes from *data to decode </p><dl class="section return"><dt>Returns</dt><dd>pointer to were resulting doubles should be stored </dd>
<dd>
the number of decoded doubles </dd></dl>

</div>
</div>
<a id="a6757248517c4cd8e2ea365565be082a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6757248517c4cd8e2ea365565be082a1">&#9670;&nbsp;</a></span>encodeLinear() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ms::numpress::MSNumpress::encodeLinear </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00001.html#a12109">double</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>dataSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00001.html#a12109">double</a>&#160;</td>
          <td class="paramname"><em>fixedPoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Encodes the doubles in data by first using a</p><ul>
<li>lossy conversion to a 4 byte 5 decimal fixed point representation</li>
<li>storing the residuals from a linear prediction after first two values</li>
<li>encoding by encodeInt (see above)</li>
</ul>
<p>The resulting binary is maximally 8 + dataSize * 5 bytes, but much less if the data is reasonably smooth on the first order.</p>
<p>This encoding is suitable for typical m/z or retention time binary arrays. On a test set, the encoding was empirically show to be accurate to at least 0.002 ppm.</p>
<p>@data pointer to array of double to be encoded (need memorycont. repr.) @dataSize number of doubles from *data to encode </p><dl class="section return"><dt>Returns</dt><dd>pointer to where resulting bytes should be stored @fixedPoint the scaling factor used for getting the fixed point repr. This is stored in the binary and automatically extracted on decoding. </dd>
<dd>
the number of encoded bytes </dd></dl>

</div>
</div>
<a id="a91bd4418b454db0c36725d65319fd527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91bd4418b454db0c36725d65319fd527">&#9670;&nbsp;</a></span>encodeLinear() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ms::numpress::MSNumpress::encodeLinear </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="a00001.html#a12109">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00001.html#a12109">double</a>&#160;</td>
          <td class="paramname"><em>fixedPoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls lower level encodeLinear while handling vector sizes appropriately</p>
<p>@data vector of doubles to be encoded </p><dl class="section return"><dt>Returns</dt><dd>vector of resulting bytes (will be resized to the number of bytes) </dd></dl>

</div>
</div>
<a id="a1b1036fcdd7c864160508d7a20ccffe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b1036fcdd7c864160508d7a20ccffe7">&#9670;&nbsp;</a></span>encodePic() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ms::numpress::MSNumpress::encodePic </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00001.html#a12109">double</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>dataSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Encodes ion counts by simply rounding to the nearest 4 byte integer, and compressing each integer with encodeInt.</p>
<p>The handleable range is therefore 0 -&gt; 4294967294. The resulting binary is maximally dataSize * 5 bytes, but much less if the data is close to 0 on average.</p>
<p>@data pointer to array of double to be encoded (need memorycont. repr.) @dataSize number of doubles from *data to encode </p><dl class="section return"><dt>Returns</dt><dd>pointer to where resulting bytes should be stored </dd>
<dd>
the number of encoded bytes </dd></dl>

</div>
</div>
<a id="a92e37701ccb73f469c2c9c9be7ec78a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92e37701ccb73f469c2c9c9be7ec78a2">&#9670;&nbsp;</a></span>encodePic() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ms::numpress::MSNumpress::encodePic </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="a00001.html#a12109">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls lower level encodePic while handling vector sizes appropriately</p>
<p>@data vector of doubles to be encoded </p><dl class="section return"><dt>Returns</dt><dd>vector of resulting bytes (will be resized to the number of bytes) </dd></dl>

</div>
</div>
<a id="a706009e575d08e367761aa1dd6187bf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a706009e575d08e367761aa1dd6187bf7">&#9670;&nbsp;</a></span>encodeSafe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ms::numpress::MSNumpress::encodeSafe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00001.html#a12109">double</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>dataSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Encodes the doubles in data by storing the residuals from a linear prediction after first two values.</p>
<p>The resulting binary is the same size as the input data.</p>
<p>This encoding is suitable for typical m/z or retention time binary arrays, and is intended to be used before zlib compression to improve compression.</p>
<p>@data pointer to array of doubles to be encoded (need memorycont. repr.) @dataSize number of doubles from *data to encode </p><dl class="section return"><dt>Returns</dt><dd>pointer to were resulting bytes should be stored </dd></dl>

</div>
</div>
<a id="a1b44c072a385e01d2653edce7409c2fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b44c072a385e01d2653edce7409c2fc">&#9670;&nbsp;</a></span>encodeSlof() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ms::numpress::MSNumpress::encodeSlof </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00001.html#a12109">double</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>dataSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00001.html#a12109">double</a>&#160;</td>
          <td class="paramname"><em>fixedPoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Encodes ion counts by taking the natural logarithm, and storing a fixed point representation of this. This is calculated as</p>
<p>unsigned short fp = log(d + 1) * fixedPoint + 0.5</p>
<p>the result vector is exactly |data| * 2 + 8 bytes long</p>
<p>@data pointer to array of double to be encoded (need memorycont. repr.) @dataSize number of doubles from *data to encode </p><dl class="section return"><dt>Returns</dt><dd>pointer to were resulting bytes should be stored </dd>
<dd>
the number of encoded bytes </dd></dl>

</div>
</div>
<a id="a69394874b8d12cf319c14442ed710f5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69394874b8d12cf319c14442ed710f5e">&#9670;&nbsp;</a></span>encodeSlof() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ms::numpress::MSNumpress::encodeSlof </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="a00001.html#a12109">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00001.html#a12109">double</a>&#160;</td>
          <td class="paramname"><em>fixedPoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls lower level encodeSlof while handling vector sizes appropriately</p>
<p>@data vector of doubles to be encoded </p><dl class="section return"><dt>Returns</dt><dd>vector of resulting bytes (will be resized to the number of bytes) </dd></dl>

</div>
</div>
<a id="a3332d228ff74b97e692fbaf4d289abe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3332d228ff74b97e692fbaf4d289abe7">&#9670;&nbsp;</a></span>optimalLinearFixedPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00001.html#a12109">double</a> ms::numpress::MSNumpress::optimalLinearFixedPoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00001.html#a12109">double</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dataSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the maximal linear fixed point that prevents integer overflow.</p>
<p>@data pointer to array of double to be encoded (need memorycont. repr.) @dataSize number of doubles from *data to encode</p>
<dl class="section return"><dt>Returns</dt><dd>the linear fixed point safe to use </dd></dl>

</div>
</div>
<a id="ad8c04bcd8e87d16b05d37f2da406032e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8c04bcd8e87d16b05d37f2da406032e">&#9670;&nbsp;</a></span>optimalLinearFixedPointMass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00001.html#a12109">double</a> ms::numpress::MSNumpress::optimalLinearFixedPointMass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00001.html#a12109">double</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dataSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00001.html#a12109">double</a>&#160;</td>
          <td class="paramname"><em>mass_acc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the optimal linear fixed point with a desired m/z accuracy.</p>
<dl class="section note"><dt>Note</dt><dd>If the desired accuracy cannot be reached without overflowing 64 bit integers, then a negative value is returned. You need to check for this and in that case abandon numpress or use optimalLinearFixedPoint which returns the largest safe value.</dd></dl>
<p>@data pointer to array of double to be encoded (need memorycont. repr.) @dataSize number of doubles from *data to encode @mass_acc desired m/z accuracy in Th</p>
<dl class="section return"><dt>Returns</dt><dd>the linear fixed point that satisfies the accuracy requirement (or -1 in case of failure). </dd></dl>

</div>
</div>
<a id="a3ad99f94b29e8e655a184535d30a3ce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ad99f94b29e8e655a184535d30a3ce7">&#9670;&nbsp;</a></span>optimalSlofFixedPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00001.html#a12109">double</a> ms::numpress::MSNumpress::optimalSlofFixedPoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00001.html#a12109">double</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dataSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Dec 9 2019 15:06:32 for OpenMS by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
